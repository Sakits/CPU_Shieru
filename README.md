# CPU Design Draft
## 一些改进

   
1. 算术指令和比较指令都可能等待寄存器，但他们利用的是不同的单元，一个用加法器一个用比较器，所以每次并行地把 RS 里 READY 的算数指令和比较指令各取一条出来执行，这并不冲突

2. ROB 里的 val 对于 Branch 指令存预测反向要跳到的地方，对于算数指令存要放到 rd 里的值

   对于 `jal` 指令，一定跳对了，所以只要存 pc + 4 等着写回 rd 就好了

   对于 `jalr` 指令，一定跳错了，所以 ROB 里只需要记录最旧的那一个 `jalr` 的 pc，commit 的时候发给 IF 跳转

   优点：
   1. 经过测试 32 位整数十分消耗资源，这样可以极大剩下空间并且不影响性能

3. 每次找空着的位置或者已经 ready 的位置可以利用 lowbit + 查找表 快速得到
4. 每个模块每次都会综合这个周期收进来的消息去向外发信息，不会导致收进来的信息延迟一个周期后才发出去

## InstFetch

两位饱和计数器分支预测 BHB

## ICache

普普通通

## Decoder

5 位指令类型 insty （指令类型 37 种，把 Load 和 Store 都只当成一种，load 的 rs2 中放长度，store 的 rd 中放长度，剩 31 种，其中 0 代表无指令）

## RegFile
~~存两排 32 个 32 位寄存器~~

~~其中一排存的是 ROB 中的最新值，这样 ROB 里就不需要存了~~

PS:找到了更省空间的方法

## ROB

只存放指令类型和 rd 位置

只存一个 jalr 的最早的那个 pc，因为一定会跳转清空

维护一个循环队列，`front` 和 `rear`，`rear + 1` 可以用 `-(~rear)` 替代*

## RS
算数计算和比较计算并行执行，每次取算数和比较各取一个 ready 的执行

每次使用 lowbit 找到第一个 ready 的数

算术计算：

1 位 flag 表示是否有效

4 位 ROB 索引，表示 RS 需要存入的寄存器对应 ROB 位置 

32 位寄存器的值，表示 RS 需要存入的寄存器的值

比较计算：

1 位 flag 表示是否有效

4 位 ROB 索引，表示 RS 需要存入的寄存器对应 ROB 位置

1 位表示比较的答案

## LSB
时序

IO 口发出请求后 stall 一个周期

非 IO 口不 stall，持续进行
