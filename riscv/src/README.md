## 一点理解

### Verilog

要先在脑中考虑好电路图，再根据电路图连线写 `verilog` 代码

电路本质上其实就是一大堆寄存器之间的连线，连线中间夹杂着一些逻辑门和选择器

#### wire

1. `wire` 就是电线，连接的过程中可以夹杂逻辑门（对数据进行运算）
2. 正因为是电线，所以只能用 `assign` 赋值，并且只能被赋值一次，一条电线肯定只有一种连法
3. 正因为是电线，所以是 `module` 里一开始就被连接好的，无关乎被写在什么位置
4. 可以用三目运算符实现 `if` 的效果

#### reg

1. `reg` 是寄存器，具有储存功能
2. 在 `@always(*)` 中**只**使用 `=` 给 `reg` 赋值，这完全等价于 `wire` 用 `assign` 赋值，寄存器需要消耗资源，所以能用 `wire` 的尽量用 `wire`
3. 在 `@always(posedge clk)` 中**只**使用 `<=` 给 `reg` 赋值，所有赋值操作是并行的，也就是可以用旧版本数据给新版本数据赋值

#### 组合与时序

1. 组合逻辑是顺序执行的；时序逻辑是并行执行的
2. 组合逻辑使用的越多，逻辑门消耗越大，时延有可能变大（取决于层数）；时序逻辑是并行的，但也因此相当于一个周期只能执行一条语句
    所以对于有先后顺序的语句，应尽量使用层数少的组合逻辑；对于无先后顺序的语句，应尽量使用时序逻辑
    **因此优化的关键就是减少逻辑的层数！！既可以减少组合时延，又可以减少时序周期数**
3. 对于需要直接自己赋值给自己的，必须使用时序逻辑
    对于需要间接自己赋值给自己的，不能使用在一个周期内就完成的组合逻辑，否则会导致综合出 `latch`（锁存器）

#### 总结 / 重点 / 设计原则
1. 尽量减少逻辑层数，合理分配组合与时序，可以流水的能用时序的就用时序，否则用层数少的组合，**一个模块内部各条可能的线路时序必须同步，否则会出现 `structural hazard`**
2. **每个模块在保证所需周期数是最少的前提下用尽量多的时序，如果使用时序会增加周期数，那么才用组合**
3. **时序逻辑用于处理数据，组合逻辑用于输出处理后的结果**
4. **output 如果是固定的一个寄存器，那么 output reg 即可；如果可能是 wire 或多个寄存器或者他们之间的运算，那么用 wire 把它们连起来**
5. 尝试不用 `@always(*)`，只用 `generate`
6. 尽量不用 `reg = `，能用 `assign wire = ` 的就用
7. 由于是电路，所以一个 `wire` 或 `reg` 都只能被赋值一次，并且只能出现在一个块中
8. 在 `@always(*)` 中只用 `reg = `，在 `@always(posedge clk)` 中只用 `reg <=`
9. 需要自己给自己赋值的，必须使用 `<=`
10. 两种解决方法，防止 `if-else` 综合出 `latch`
   1. 组合逻辑中的 `if-else` 结构必须完整，每个变量赋值都必须同时出现在 `if` 和 `else` 中，消耗逻辑门较多
   2. 需要出现在 `if-else` 中的变量一定要赋初值，然后用有优先级的 `if-else` 判断，时延较长
11. 只有两个分支的可以用三目运算符，多分支的最好还是用 `if` 或者 `case`
12. 善用 `generate` 生成一层组合逻辑
13. 逻辑门消耗：加法器 > 比较器 > 选择器
    因此先选择，再比较，再作加法

## CPU Design
### 一些改进
1. ROB 里不存要放进 rd 里的值，只存放指令类型和 rd 位置
   在 RegFile 里多开 31 个（[31:1]） 32 位寄存器，表示当前寄存器的最新结果（未被 commit）
   优点：
      1. Decoder 不需要再去 ROB 里找值了，时延降低
      2. ROB 中可以存放更少的信息，与 RegFile 里多开消耗的资源几乎抵消
      3. 写起来更方便
2. PS：写一半被告知板上一个地址的内存只能读一次，所以下面这个优化寄了
   ~~乱序 load~~
   ~~load 优先级大于 store~~
   ~~一个 load 有三种状态~~
   ~~1. READY，已经读到需要的值~~
   ~~2. WAIT_ROB，等待 RS 计算出它需要的值或者 Load 出它需要的值~~
   ~~3. WAIT_MEM，等待去内存里读取需要的值~~
   
   ~~每次把一个 load 塞进 Read Buffer 的时候，先去 Write Buffer 里找到最大下标的（使用 lowbit 可以快速找到）出现这个地址的 index，如果该 store 已经 Ready，那么直接读值过来然后 READY，否则记录该 Store 在等待的 RS，设为 WAIT_RS；如果找不到地址相同的 index，那么状态为 WAIT_MEM~~

   ~~优点：快~~
   ~~缺点：可能组合逻辑会复杂一些，不过相比 Decoder 是小巫见大巫~~

3. 修改了上面的优化适应板子的特性（特性？），每次 Load 加入的时候，遍历一遍 LSB 里的 store，**看看有没有同地址的 store，如果有，就相应的设为 READY 或者 WAIT_ROB，就不需要去 MEM 里读了**，否则还是等着去 MEM 里读。
   
   每次找到一个 READY 但没发送过的下标最小（最靠近队头）的 Load 发送给 RS 和 LSB 和 ROB

   队头如果发送过就弹出

   Load 也需要 commit 之后再读内存（板子的奇妙特性）

   **每次 Write 加入的时候，也可以看看有没有同地址的 store，如果有，那么那个 store 也可以不存进 MEM 了**

   优点：
   1. 让很多 Store 和 Load 都不需要访问内存了
   2. 因为 LSB 里每个位置都有可能是 store，而 store 必然有等待 RS 的接口，当他是 load 的时候，这个接口就被浪费了，但是这么做就可以利用上这个接口
 
   缺点：
   1. 组合逻辑稍微复杂一点点

## API

### InstFetch

#### ICache
##### 输入
1 位 flag 表示上一条指令是否已经获得
##### 输出
32 位 pc
32 位预测失败要跳到的 pc

#### ROB
##### 输入
1 位表示是否预测错误

32 位表示需要跳转到的 pc

### ICache
#### InstFetch
##### 输入
32 位 pc
32 位预测失败要跳到的 pc

#### MemCtrl
##### 输入
1 位 flag 表示是否有效
32 位指令
##### 输出
1 位 flag 表示是否有效
32 位 pc


#### Decoder
1 位 flag 表示是否有效
32 位指令
32 位预测失败要跳到的 pc

#### RAM

两位饱和计数器分支预测 BHB

### ICache

### Decoder

#### 输入
##### I-Cache
1 位 flag 表示是否有效
32 位指令 ins



##### RegFile
32 位寄存器值 reg1, reg2

1 位寄存器有效值 reg1_flag, reg2_flag 表示两个寄存器值是真值还是 renaming 后的值

#### 输出
32 位立即数 imm 

5 位寄存器编号 rd rs1 rs2，若无则设为 0

5 位指令类型 insty （指令类型 37 种，把 Load 和 Store 都只当成一种，load 的 rs2 中放长度，store 的 rd 中放长度，剩 31 种，其中 0 代表无指令）

32 位寄存器值 reg1_val，reg2_val 表示两个寄存器的真值或者 renaming 后的值（ready 则为真值）

1 位寄存器有效值 reg1_flag, reg2_flag 表示两个寄存器值是真值还是 renaming 后的值

##### LSB
3 位指令类型 lsb_insty （8 种）

指令类型设计时让 LSB 是 0 ~ 7
##### RS
5 位指令类型 rs_insty
#### 内部
使用时序逻辑

注意 if 的设计使得逻辑层数减少

去 reg_file 里找 rs1 和 rs2 的最新值

#### ROB
#### 输入

##### Decoder
1 位 flag 表示是否有效

1 位 predic 表示预测跳还是不跳

5 位寄存器编号 rd，若无则设为 0

5 位指令类型 insty （指令类型 37 种，把 Load 和 Store 都只当成一种，load 的 rs2 中放长度，store 的 rd 中放长度，剩 31 种，其中 0 代表无指令）

##### RS
算术计算：

1 位 flag 表示是否有效

4 位 ROB 索引，表示 RS 需要存入的寄存器对应 ROB 位置 

32 位寄存器的值，表示 RS 需要存入的寄存器的值

比较计算：

1 位 flag 表示是否有效

4 位 ROB 索引，表示 RS 需要存入的寄存器对应 ROB 位置

1 位表示比较的答案

##### LSB
1 位 flag 表示是否有效

4 位 ROB 索引，表示 LSB 需要存入的寄存器对应 ROB 位置

32 位寄存器的值，表示 LSB 需要存入的寄存器的值

#### 输出
##### RegFile 
组合逻辑：
1 位 flag 表示是否有效

5 位 Reg 索引，表示 ROB 需要存入的寄存器对应 Reg 位置

32 位寄存器的值，表示 ROB 需要存入的寄存器的值

5 位 Reg 索引表示 ROB commit 的寄存器位置，若无 commit 则为 0

##### LSB
1 位 flag 表示允许写入

##### IF
1 位 flag 表示判断跳转是否正确
32 位 pc 表示应该跳转到哪里

#### 内部
使用时序逻辑

维护一个循环队列，`front` 和 `rear`，加一可以用 `-(~rear)` 替代*

队列每个元素维护是否 ready

维护是否已满

如果是算术 / Load 指令，把值传给 RegFile

如果是 Store 指令，告知 LSB 第一个未 commit 的 Store 已经 commit，允许写入

如果是 Branch 指令，判断跳转是否正确，如果正确直接 commit 不管，否则给所有模块发指令进行清空

整个 ROB 只存一个 jalr 的最老的那个 pc，因为一定会跳转清空

